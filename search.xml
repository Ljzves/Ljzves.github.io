<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[后缀数组学习笔记]]></title>
    <url>%2F2017%2F05%2F22%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[定义字符串$s$的起始位置为1长度为$len$，$s[i]$表示字符串第$i$位的字符。后缀：用$suff[i]$表示由$s[i]~s[len]$组成的字符串。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>OI</tag>
        <tag>后缀数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流笔记]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[网络流是什么是网络流是一种类比水流的解决问题方法，与线性规划密切相关。虽然模型简单，但是应用却十分广泛。 Dinic算法Dinic算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在$O(n^2m)$的时间内求出网络的最大流。在加入多路增广和当前弧优化后，复杂度远小于理论上界。 变量解释$no[x]$是点$x$的指针 $level$：表示层数 $fir$：表示邻接表中的第一条边 $curr$：当前弧优化，表示目前访问到的边 $Edge*$ 是边指针 $next$：表示下一条边 $to$：表示指向节点 $res$：表示反向边 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Dinic &#123; public: int operator() (int s, int t, int n) &#123; int max_flow = 0; while (bfs(&amp;no[s], &amp;no[t], n)) &#123; max_flow += dfs(&amp;no[s], &amp;no[t]); &#125; return max_flow; &#125; private: // 建立层次网络 bool bfs(Node *s, Node *t, int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; no[i].level = -1; no[i].curr = no[i].fir; &#125; std::queue&lt;Node *&gt; q; s-&gt;level = 1; q.push(s); while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;fir; e; e = e-&gt;next) &#123; if (e-&gt;flow != 0 &amp;&amp; e-&gt;to-&gt;level == -1) &#123; e-&gt;to-&gt;level = v-&gt;level+1; if (e-&gt;to == t) return true; q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; // 寻找增广路 int dfs(Node *s, Node *t, int limit = oo) &#123; if (s == t) return limit; int cnt_flow = 0; // cnt_flow 记录已使用的流量，以达到多路增广的效果 for (Edge *&amp;e = s-&gt;curr; e; e = e-&gt;next) &#123; // 注意 *&amp;e 这样才能起到当前弧优化的效果 if (e-&gt;flow != 0 &amp;&amp; e-&gt;to-&gt;level == s-&gt;level+1) &#123; int flow = dfs(e-&gt;to, t, std::min(limit-cnt_flow, e-&gt;flow)); cnt_flow += flow; e-&gt;flow -= flow; e-&gt;res-&gt;flow += flow; if (cnt_flow == limit) return cnt_flow; &#125; &#125; if (cnt_flow != limit) s-&gt;level = -1; // 这是个小优化，至于为什么留给读者自己思考。 return cnt_flow; &#125;&#125;dinic; 模板题地址LYOI 重要结论及模型 记 $ S $ 为源点，$T$为汇点，$c(u,v)$为在点u,v之间的容量。 最大流最小割定理 最大流等于最小割 详细证明请参考《最小割模型在信息学竞赛中的应用》hbt hbt. 胡伯涛 2007年国家集训队论文《最小割模型在信息学竞赛中的应用》 &#8617; 二分图最大匹配构图设二分图\(G=(V_1,V_2,E)\)$\begin{cases}c(s,u) = 1,&amp;u\in V_1\c(u,v)=1,&amp;\langle u,v\rangle\in E\c(v,t)=1,&amp;v\in V_2\end{cases}$答案就是最大流 模型理解这个模型比较好理解，因为每个点的流量至多为1，保证了每个点只能用一次。 方案输出遍历第二部分的边，如果满流则就是一对匹配。 最大权闭合子图构图 \begin{cases} c(u,v)=\infty,&\langle u,v\rangle\in E\\ c(s,u)=w_u,&w_u>0\\ c(u,t)=-w_u,&w_u0]-maxflow;模型理解证明比较复杂，详细证明请参考hbt。 方案输出最小割即为方案 最小路径覆盖构图 将一个点拆成两个点一个表示入，一个表示出，答案就是最大匹配。 上下界网络流推荐阅读Menci的blog。很详细，对四种情况都进行了讨论。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>OI</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt学习笔记]]></title>
    <url>%2F2017%2F05%2F18%2Fqt%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、常用控件菜单栏123456789101112131415#include &lt;QMenuBar&gt;#include &lt;QMenu&gt;#include &lt;QAction&gt;...// 菜单栏QMenuBar *mBar = menuBar();// 添加菜单QMenu *pFile = mBar-&gt;addMenu("文件");// 菜单项和动作QAction *pNew = pFile-&gt;addAction("新建");connect(pNew, &amp;QAction::triggered, [=]() &#123; qDebug() &lt;&lt; "新建被触发";&#125;);pFile-&gt;addSeparator(); // 分割线QAction *pOpen = pFile-&gt;addAction("打开"); 工具栏工具栏的实质是菜单栏的快捷方式 123456#include &lt;QToolBar&gt;...QToolBar *toolBar = addToolBar(&quot;toolBar&quot;);toolBar-&gt;addAction(pNew);QPushButton *qButton = new QPushButton(this);toolBar-&gt;addWidget(qButton); 状态栏12345678#include &lt;QStatusBar&gt;...QStatusBar *sBar = statusBar();QLabel *lable = new QLabel(this); lable-&gt;setText(&quot;Normal&quot;);sBar-&gt;addWidget(lable);sBar-&gt;addWidget(new QLabel(&quot;2&quot;, this));sBar-&gt;addPermanentWidget(new QLabel(&quot;3&quot;, this)); 核心控件核心控件有很多这里只是随便展示一种 1234#include &lt;QTextEdit&gt;...QTextEdit *textarea = new QTextEdit(this);setCentralWidget(textarea); 浮动窗口123456#include &lt;QDockWidget&gt;... QDockWidget *dw = new QDockWidget(this);addDockWidget(Qt::RightDockWidgetArea, dw);QTextEdit *textarea2 = new QTextEdit(this);dw-&gt;setWidget(textarea2); 对话框1234567891011121314151617181920212223242526272829303132333435363738QMenuBar *mBar = menuBar(); setMenuBar(mBar);QMenu *menu = mBar-&gt;addMenu(&quot;对话框&quot;);QAction *p1 = menu-&gt;addAction(&quot;模态对话框&quot;);connect(p1, &amp;QAction::triggered, [=]() &#123; QDialog dlg; dlg.exec(); qDebug() &lt;&lt; &quot;1&quot;;&#125;);QAction *p2 = menu-&gt;addAction(&quot;非模态对话框&quot;);connect(p2, &amp;QAction::triggered, [=]() &#123; QDialog *dlg = new QDialog; dlg-&gt;setAttribute(Qt::WA_DeleteOnClose); dlg-&gt;show(); qDebug() &lt;&lt; &quot;2&quot;;&#125;);QAction *p3 = menu-&gt;addAction(&quot;关于对话框&quot;);connect(p3, &amp;QAction::triggered, [=]() &#123; QMessageBox::about(this, &quot;关于&quot;, &quot;Copyright 2016~2017&quot;);&#125;);QAction *p4 = menu-&gt;addAction(&quot;问题对话框&quot;);connect(p4, &amp;QAction::triggered, [=]() &#123; int ret = QMessageBox::question(this, &quot;question&quot;, &quot;Are you ok?&quot;); switch (ret) &#123; case QMessageBox::Yes: qDebug() &lt;&lt; &quot;I&apos;m ok&quot;; break; case QMessageBox::No: qDebug() &lt;&lt; &quot;I&apos;m not ok&quot;; break; &#125;&#125;);QAction *p5 = menu-&gt;addAction(&quot;文件对话框&quot;);connect(p5, &amp;QAction::triggered, [=]() &#123; QString path = QFileDialog::getOpenFileName(this, &quot;open&quot;, &quot;../&quot;, &quot;souce(*.cpp*.h);;Text(*.txt);;All(*.*)&quot; ); qDebug() &lt;&lt; path;&#125;);]]></content>
      <tags>
        <tag>工程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2017%2F05%2F15%2FGithub%2F</url>
    <content type="text"><![CDATA[git命令整理基本概念 仓库(Repository)：用来存放项目代码。 收藏(Star)：就是收藏 分叉(fork)：复制一个项目，作为个人项目修改。 合并请求(Pull request) 关注(Watch) (lssue) 命令 git config —global user.name ‘’ git config —global user.email ‘’ git init：初始化仓库 git status：文件状态 git add ：加入到缓存区 git commit -m “” ：添加到库中 git log：日志 git log —pretty=oneline ：简略版日志 git reset —hard 3628164 ：会到历史版本 git reset —hard HEAD^ ：回到上一个版本 git reflog ：用来记录你的每一个命令 git reset HEAD readme.txt ：撤回 git checkout — : 用版本库里的版本替换工作区的版本 关联远程库 ssh-keygen -t rsa -C “youremail@example.com” git remote add origin git@github.com:michaelliao/learngit.git git push -u origin master 分支查看分支：git branch创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 分支合并图：git log —graph 教程推荐Git教程]]></content>
      <tags>
        <tag>工程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>